## Architecture Design Principles

The ChannelPipeline framework follows several key design principles:

### Decoupling and Extensibility

The core ChannelPipeline implementation is designed to be unaware of specific features like plugins or storage. Instead, it provides an extension mechanism through the following components:

- **IPipelineResource Interface**: Defines a contract for resources that need to be notified of pipeline lifecycle events
- **PipelineResourceRegistry**: Centralized registry that manages resources attached to pipelines
- **Resource Adapters**: Connect specific implementations (like plugins or storage) to the generic resource system

This architecture allows:

- Adding new features without modifying the core pipeline code
- Testing components in isolation
- Selecting only the features you need

### Named Storage

The storage system supports multiple named storage instances within a single pipeline, making it easier to organize different types of data:

```csharp
// Add multiple storage instances with different names
var pipeline = new ChannelPipeline<string>()
    .WithStorage<string, string, int>()                                 // Default storage
    .WithStorage<string, string, string>("cache")                       // Named cache storage
    .WithStorage<string, string, Dictionary<string, object>>("metadata"); // Named metadata storage

// Retrieve storage by name
var defaultStorage = pipeline.GetStorage<string, int>();             // Default storage
var cacheStorage = pipeline.GetStorage<string, string>("cache");     // Named cache storage
var metadataStorage = pipeline.GetStorage<string, Dictionary<string, object>>("metadata");

// Use named storage in modifiers
StorageBlockModifiers.StoreResult<string, string>(
    pipeline,
    text => text,
    "cache" // Specify which storage to use
);
```

### Advanced Storage Features

The framework provides several specialized storage implementations for different scenarios:

#### Expiring Storage

Automatically expires entries after a specified time:

```csharp
// Create an expiring cache with 5 minute timeout
var cache = StorageFactory.WithExpiration<string, string>(
    StorageFactory.InMemory<string, string>(),
    TimeSpan.FromMinutes(5));

// Add to pipeline
var pipeline = new ChannelPipeline<string>()
    .WithStorage<string, string, string>("cache", cache);
```

#### Layered Storage

Combines multiple storage instances with fallback behavior:

```csharp
// Create a two-tiered cache (fast memory + persistent)
var tieredStorage = StorageFactory.Layered<string, string>(
    primaryStorage,   // Try this first
    fallbackStorage   // Try this if primary misses
);
```

#### Storage Factory

Fluent API for creating storage instances:

```csharp
// Create different storage types
var memoryStorage = StorageFactory.InMemory<string, int>();
var expiringStorage = StorageFactory.WithExpiration<string, string>(null, TimeSpan.FromHours(1));
var layeredStorage = StorageFactory.Layered(memoryStorage, expiringStorage);
```

#### Enhanced Modifiers

Additional modifiers for common patterns:

```csharp
// Store custom values derived from results
StorageBlockModifiers.StoreValue<string, string, int>(
    pipeline,
    text => $"{text}_length", // Generate key 
    text => text.Length,     // Generate value
    "stats"                  // Storage name
);

// Capture errors during processing
StorageBlockModifiers.CaptureErrors<string, string>(
    pipeline,
    text => text,           // Key selector
    "errors"                // Storage name
);
```

### Using the Decoupled Architecture

```csharp
// Create a pipeline resource (implements IPipelineResource)
public class MetricsResource : IPipelineResource 
{
    private readonly IMetricsClient _metrics;

    public MetricsResource(IMetricsClient metrics)
    {
        _metrics = metrics;
    }

    public void OnPipelineDisposing(object pipeline)
    {
        _metrics.RecordPipelineCompleted();
    }
}

// Register with a pipeline
var pipeline = new ChannelPipeline<string>();
PipelineResourceRegistry.RegisterResource(pipeline, new MetricsResource(metricsClient));
```

This architecture makes it easy to add new capabilities to pipelines without increasing coupling or complexity in the core implementation.
